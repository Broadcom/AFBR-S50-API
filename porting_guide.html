<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AFBR-S50 API Reference Manual: MCU Porting Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="AFBR-S50.ico"/></td>
  <td id="projectalign">
   <div id="projectname">AFBR-S50 API Reference Manual<span id="projectnumber">&#160;v1.6.5</span>
   </div>
   <div id="projectbrief">AFBR-S50 Time-of-Flight Sensor SDK for Embedded Software</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('porting_guide.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">MCU Porting Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__doxygen_204__porting__guide"></a></p>
<h1><a class="anchor" id="pg_introduction"></a>
Introduction</h1>
<p>The following section gives an brief overview on how to integrate the <b>AFBR-S50 Core Library and API</b> into an user application and how to port the library to another platform. See the <a class="el" href="#sw_overview">Fig. 4.1</a> for a visualization of the integration progress. The API is embedded into the user application where both are accessing the hardware peripherals via the driver and HAL layers.</p>
<p><a class="anchor" id="sw_overview"></a></p><div class="image">
<img src="4_1_sw_overview.png" alt=""/>
<div class="caption">
Fig. 4.1: An overview of the AFBR-S50 software architecture for integration into an user application.</div></div>
 <p>The basic idea to port the API to a new platform is to adjust the HAL to the new hardware and implement the functionality that is required by the core library to interface with the <b>AFBR-S50</b> sensor device through the given peripherals. The following sections give an overview on the hardware interface layers and finally show a step-by-step guide on how to accomplish the porting task.</p>
<h1><a class="anchor" id="pg_toolchain"></a>
Toolchain Compatibility</h1>
<p>The <b>AFBR-S50 Core Library</b> is build and tested using the <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain">GNU Embedded Toolchain for Arm</a>. However, any other toolchain that supports <b>AEABI</b> compatible library linking should work fine with the library files. Note that builds that utilize these toolchains are not tested nor verified and can not be officially supported!</p>
<p>If you still have to use one of these, make sure to read the <a href="https://developer.arm.com/documentation/dai0487/latest/">Binary Interoperability Between Toolchains Application Note</a> by ARM to understand the implications of mixing code from different toolchains.</p>
<p>As mentioned above, the <b>AFBR-S50 Core Library</b> is build with <b>AEABI</b> compatibility enabled (i.e. with the <code>-library_interface=aeabi_clib</code> compiler flag). The following GNU toolchain settings are used to compile the libraries:</p>
<ul>
<li><code>-library_interface=aeabi_clib</code>: Specifies that the compiler output is <b>AEABI</b> compliant.</li>
<li><code>-mfloat-abi=softfp</code>: Software floating-point Procedure Call Standard (PCS) and hardware floating point instructions.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The <b>AFBR-S50</b> code does not use any floating-point nor <code>wchar_t</code> values at all.</dd></dl>
<h1><a class="anchor" id="pg_architecture"></a>
Architecture Compatibility</h1>
<p>The <b>AFBR-S50 Core Library</b> is compatible with all <a href="https://developer.arm.com/ip-products/processors/cortex-m">Arm Cortex-M Series Processors</a>. The library is optimized for the smallest variants, the <b>Cortex-M0/M0+</b>. However, the upwards compatibility of the Cortex-Mx family makes it easy to run the same library on higher architectures without effort as well. The library artifacts are compiled for the most common architectures.</p>
<p>The following API variants are available:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Library Name   </th><th class="markdownTableHeadNone">Architecture   </th><th class="markdownTableHeadNone">FPU   </th><th class="markdownTableHeadNone">ABI   </th><th class="markdownTableHeadNone">Optimization    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>afbrs50_m0</code>   </td><td class="markdownTableBodyNone">Cortex-M0/M0+   </td><td class="markdownTableBodyNone">none   </td><td class="markdownTableBodyNone">soft   </td><td class="markdownTableBodyNone">performance    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>afbrs50_m0_os</code>   </td><td class="markdownTableBodyNone">Cortex-M0/M0+   </td><td class="markdownTableBodyNone">none   </td><td class="markdownTableBodyNone">soft   </td><td class="markdownTableBodyNone">memory size    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>afbrs50_m3</code>   </td><td class="markdownTableBodyNone">Cortex-M3   </td><td class="markdownTableBodyNone">none   </td><td class="markdownTableBodyNone">soft   </td><td class="markdownTableBodyNone">performance    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>afbrs50_m3_os</code>   </td><td class="markdownTableBodyNone">Cortex-M3   </td><td class="markdownTableBodyNone">none   </td><td class="markdownTableBodyNone">soft   </td><td class="markdownTableBodyNone">memory size    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>afbrs50_m4</code>   </td><td class="markdownTableBodyNone">Cortex-M4/M7   </td><td class="markdownTableBodyNone">none   </td><td class="markdownTableBodyNone">soft   </td><td class="markdownTableBodyNone">performance    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>afbrs50_m4_os</code>   </td><td class="markdownTableBodyNone">Cortex-M4/M7   </td><td class="markdownTableBodyNone">none   </td><td class="markdownTableBodyNone">soft   </td><td class="markdownTableBodyNone">memory size    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>afbrs50_m4_fpu</code>   </td><td class="markdownTableBodyNone">Cortex-M4/M7   </td><td class="markdownTableBodyNone">FPv4-SP   </td><td class="markdownTableBodyNone">hard   </td><td class="markdownTableBodyNone">performance    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>afbrs50_m4_fpu_os</code>   </td><td class="markdownTableBodyNone">Cortex-M4/M7   </td><td class="markdownTableBodyNone">FPv4-SP   </td><td class="markdownTableBodyNone">hard   </td><td class="markdownTableBodyNone">memory size   </td></tr>
</table>
<p>Architecture:</p>
<ul>
<li>Cortex-M0: <code>-mcpu=cortex-m0</code></li>
<li>Cortex-M3: <code>-mcpu=cortex-m3</code></li>
<li>Cortex-M4: <code>-mcpu=cortex-m4</code></li>
</ul>
<p>FPU (Fixed-Point Unit)</p>
<ul>
<li><code>none</code>: No floating-point hardware unit</li>
<li><code>FPv4-SP</code>: Hardware floating-point support (<code>-mfpu=fpv4-sp-d16</code>)</li>
</ul>
<p>ABI (Application Binary Interface):</p>
<ul>
<li>soft: Software Floating-point support and ABI (<code>-mfloat-abi=soft</code>)</li>
<li>hard: Hardware floating-point support and ABI (<code>-mfloat-abi=hard</code>)</li>
</ul>
<p>Optimization Level:</p>
<ul>
<li>performance: The compiler optimized for best performance (<code>-O3</code>)</li>
<li>memory size: The compiler optimized for lowest memory usage (<code>-Os</code>)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>When using another hardware floating point unit, the application must be linked using the <code>-mfloat-abi=softfp</code> GNU compiler flag, enabling the software floating-point PCS and hardware floating-point instruction support. The <b>AFBR-S50 Core Library and API</b> does not use any floating point operations anyhow.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>For more information on the topic see for example <a href="https://embeddedartistry.com/blog/2017/10/11/demystifying-arm-floating-point-compiler-options/">this blog</a>.</dd></dl>
<h1><a class="anchor" id="pg_hardware"></a>
Hardware Compatibility</h1>
<p>The <b>AFBR-S50 Core Library</b> is build and tested using the <a href="https://www.nxp.com/design/development-boards/freedom-development-boards/mcu-boards/freedom-development-platform-for-kinetis-kl3x-and-kl4x-mcus:FRDM-KL46Z">NXP FRDM-KL46Z</a> development platform that contains a <a href="https://developer.arm.com/ip-products/processors/cortex-m/cortex-m0-plus">ARM Cortex-M0+</a> processor. The instruction set available on the <b>Cortex-M0</b> is a subset of all the instruction sets available on higher Cortex-Mx processor cores like <a href="https://developer.arm.com/ip-products/processors/cortex-m/cortex-m3">ARM Cortex-M3</a> or <a href="https://developer.arm.com/ip-products/processors/cortex-m/cortex-m4">ARM Cortex-M4</a>. Therefore the library can be used on any <b>Cortex-Mx</b> based platforms that contain the required hardware peripherals. These are:</p>
<p>Mandatory hardware peripherals are</p>
<ul>
<li>an SPI Interface w/ GPIO access,</li>
<li>an additional single GPIO IRQ line,</li>
<li>a lifetime counter that is able to keep track of timing in the magnitude of microseconds during the full lifetime of the embedded system.</li>
</ul>
<p>Furthermore, optional peripherals are</p>
<ul>
<li>a periodic interrupt timer to trigger measurements on a time based schedule by interrupts,</li>
<li>a non-volatile memory interface (e.g. flash) to save user calibration data beyond a power or reset cycle.</li>
</ul>
<p>Minimum memory requirements:</p>
<ul>
<li>RAM: 8kByte (4kByte Heap + 4kByte Stack)</li>
<li>ROM/Flash: 128 kByte</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>These requirements are the minimum values for the <b>AFBR-S50 Core Library and API</b> only! Additional memory for user application is not considered here and must be added accordingly.</dd></dl>
<p>The following section gives a brief overview on the corresponding hardware layers.</p>
<h1><a class="anchor" id="pg_hw_layers"></a>
Hardware Layers</h1>
<p>The AFBR-S50 API basically supports any ARM Cortex-Mx based microcontroller platform. Merely the hardware layers need to be adopted to match the underlying hardware. The API defines interfaces for all required hardware modules and the corresponding methods. Refer <a class="el" href="#sw_overview">Fig. 4.1</a> to get an overview of the required hardware abstraction layer modules. The interfaces are assembled in the <a class="el" href="group__argus__hal.html">platform module</a> of the API. Each module contains a detailed description on how to implement the corresponding interface. The enclosed example code that comes with the AFBR-S50 SDK also provides implementations of the hardware layers based on the NXP MKL46z platform as a reference. See the <a class="el" href="getting_started.html">getting started</a> section on how to build and run the examples on the provided evaluation platform.</p>
<p>The <b>AFBR-S50</b> core has the capability to perform the device operation self-sustained in the background by hopping from interrupt to interrupt without blocking the main processor thread. Therefore all peripheral drivers must be implemented asynchronously, such that an operation is invoked from the API and returns immediately. After finishing the corresponding operation, a callback must be invoked in order to perform the next step in the current sequence. Especially, for the timer interface, there is the requirement of periodic interrupts to be invoked in order to start the measurement cycle in the background without the requirement to call the corresponding function from the application main thread. However, in order to not overload the processor (i.e. from within the interrupt service routines), the data evaluation must be executed from the main thread after the raw measurement data has been read from the device.</p>
<h2><a class="anchor" id="pg_s2pi"></a>
S2PI (= SPI + GPIO) Layer</h2>
<p>The S2PI module is a combination of SPI and GPIO hardware. The communication with the device requires an SPI peripheral. To increase speed and lower the CPU load, it is recommended to use a DMA module along with the SPI interface. The measurement data ready event occurs when the measurement cycle on the device is finished and the data is ready to read. A single GPIO IRQ invoking a callback to the API core is required and incorporated into the SPI module.</p>
<p>In addition to the standard SPI interface, the corresponding pins must also be accessible in GPIO mode. This is required to access the EEPROM memory of the AFBR-S50 sensor device that holds calibration parameters. The EEPROM interface is connected to the SPI pins to decrease the complexity in pinning and wiring. The EEPROM interface is not compatible with any standard SPI interface and thus it is emulated in software using bit banging algorithms. A mechanism to switch forth and back between SPI and GPIO mode for the corresponding pins is incorporated into the S2PI module.</p>
<dl class="section note"><dt>Note</dt><dd>The EEPROM read sequence (and herein the GPIO mode) is only executed once upon device initialization. This is, during the <a class="el" href="group__argus__api.html#ga7d724a6657138f112bff554f7db2a898" title="Initializes the device with default measurement mode.">Argus_Init</a> or <a class="el" href="group__argus__api.html#gab1dd6c99418b2e470a29b85721edc93f" title="Reinitializes the device with the current measurement mode.">Argus_Reinit</a> API functions. The EEPROM is not accessed while active distance measurements are executed and thus the GPIO toggle speed does not impact the device performance.</dd></dl>
<h3><a class="anchor" id="autotoc_md26"></a>
S2PI Overview</h3>
<p>The module needs to provide two different modes of operation, both as SPI master:</p>
<ol type="1">
<li><p class="startli"><em>A fast SPI mode for accessing the device</em></p>
<p class="startli">The fast SPI mode is used for accessing the device for all purposes (initialization, configuration, calibration and measurement).</p>
<p class="startli">Obviously, to allow a continuous data transfer on the SPI interface without creating a high load on the microcontroller itself, although not strictly required, it is strongly recommended to set up DMA transfer for the SPI interface. The following description assumes that DMA is used.</p>
</li>
<li><p class="startli"><em>A slow GPIO mode for accessing the EEPROM</em></p>
<p class="startli">Calibration data is stored on a small EEPROM that needs to be read upon device initialization at a much lower speed. The readout is performed on the same interface as the fast SPI, but with a bit-banging mechanism that allows the control of all signals with a much slower timing as GPIOs.</p>
<p class="startli">The bit-banging mechanism is already built into the library, so the hardware layer only has to provide:</p><ul>
<li>A mechanism to switch between the two operation modes</li>
<li>A mechanism to set the GPIO pins to the required state</li>
</ul>
<p class="startli">The EEPROM readout is performed only during initialization, so the speed does not negatively affect measurement performance.</p>
</li>
</ol>
<p>See the <a class="el" href="group__argus__s2pi.html">S2PI module</a> documentation for more details on the SPI interface.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the EEPROM readout fails the device operates in an uncalibrated mode which will result in decreased device performance! Please make sure to catch this case by checking the error return code if the <a class="el" href="group__argus__api.html#ga7d724a6657138f112bff554f7db2a898" title="Initializes the device with default measurement mode.">Argus_Init</a> function (<a class="el" href="group__argus__status.html#gga67a0db04d321a74b7e7fcfd3f1a3f70bab6d45f3ac20a25b5d9b33ab2565f6f0c">ERROR_ARGUS_UNKNOWN_MODULE</a>). Also refer to the <a class="el" href="faq.html#faq_eeprom">troubleshooting section</a> for additional info on how to debug the GPIO mode.</dd></dl>
<h3><a class="anchor" id="autotoc_md27"></a>
S2PI Initialization</h3>
<p>The SPI hardware layer is required to be initialized before the first call to the core library.</p>
<h4><a class="anchor" id="autotoc_md28"></a>
S2PI Pin configuration</h4>
<ol type="1">
<li><p class="startli"><code>CLK</code>, <code>MOSI</code>, <code>MISO</code></p>
<p class="startli">The SPI communications requires the three standard pins <code>CLK</code> (SPI clock), <code>MOSI</code> (master out, slave in) and <code>MISO</code> (master in, slave out) to be switchable between SPI and GPIO modes.</p>
<p class="startli">The <code>CLK</code> and <code>MOSI</code> lines are configured as output and the <code>MISO</code> is configured as input. The <code>MISO</code> is actively driven by the device and thus no pull-up resistor is required.</p>
</li>
<li><p class="startli"><code>CS</code></p>
<p class="startli">Even though it is expected that the device is the only device on the SPI interface, a <code>CS</code> (chip select) signal is required to be asserted on every SPI transfer. Depending on the SPI capabilities, this may be either handled by the SPI peripheral (hard <code>CS</code>) or by GPIO toggling (soft <code>CS</code>).</p>
<p class="startli">This signal is active low and is asserted during transfers. The signal must be cycled to high between transfers.</p>
</li>
<li><p class="startli"><code>IRQ</code></p>
<p class="startli">This is an input line that allows the device to signal that measurement data is available and ready for transfer.</p>
<p class="startli">This signal is active low and will be asserted until the next SPI transfer is started, which is assumed to pick up the data. The GPIO should be configured as input triggering an interrupt on the falling edge. Take care that a GPIO with a unique interrupt ID is picked for this line, or no other GPIO attached to the same interrupt ID is configured to trigger any interrupts. The IRQ line needs a pull-up resistor set.</p>
</li>
</ol>
<p>Be also careful with the initialization regarding:</p>
<ul>
<li>The speed of GPIO changes: fast</li>
<li>The type of output: push-pull</li>
<li>The signal level: 3V3</li>
</ul>
<p>The following table provides an overview over the GPIO configurations:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadCenter">CLK   </th><th class="markdownTableHeadCenter">MOSI   </th><th class="markdownTableHeadCenter">MISO   </th><th class="markdownTableHeadCenter">CS   </th><th class="markdownTableHeadCenter">IRQ    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Direction   </td><td class="markdownTableBodyCenter">Output   </td><td class="markdownTableBodyCenter">Output   </td><td class="markdownTableBodyCenter">Input   </td><td class="markdownTableBodyCenter">Output   </td><td class="markdownTableBodyCenter">Input    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Drive Mode   </td><td class="markdownTableBodyCenter">Push-Pull   </td><td class="markdownTableBodyCenter">Push-Pull   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Push-Pull   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Pull-Up   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">None   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Pull Up    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Interrupt   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Falling Edge    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Speed   </td><td class="markdownTableBodyCenter">Fast   </td><td class="markdownTableBodyCenter">Fast   </td><td class="markdownTableBodyCenter">Fast   </td><td class="markdownTableBodyCenter">Fast   </td><td class="markdownTableBodyCenter">Fast    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Signal Level   </td><td class="markdownTableBodyCenter">3V3   </td><td class="markdownTableBodyCenter">3V3   </td><td class="markdownTableBodyCenter">3V3   </td><td class="markdownTableBodyCenter">3V3   </td><td class="markdownTableBodyCenter">3V3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Mode for SPI   </td><td class="markdownTableBodyCenter">SPI   </td><td class="markdownTableBodyCenter">SPI   </td><td class="markdownTableBodyCenter">SPI   </td><td class="markdownTableBodyCenter">SPI or GPIO   </td><td class="markdownTableBodyCenter">GPIO    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Mode for GPIO   </td><td class="markdownTableBodyCenter">GPIO   </td><td class="markdownTableBodyCenter">GPIO   </td><td class="markdownTableBodyCenter">GPIO   </td><td class="markdownTableBodyCenter">GPIO   </td><td class="markdownTableBodyCenter">(not used)   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md29"></a>
SPI Mode</h4>
<p>The device works with <code>CPOL=1</code> (clock polarity) and <code>CPHA=1</code> (clock phase), meaning that the clock is pulled high in idle state and the data should be read on the rising clock edge. This is also frequently referred to SPI mode 3. This must be configured accordingly:</p>
<ul>
<li><code>CPOL = 1</code></li>
<li><code>CPHA = 1</code></li>
</ul>
<h4><a class="anchor" id="autotoc_md30"></a>
SPI Speed</h4>
<p>The speed is crucial to achieve a high frame rate when performing continuous measurements: As each measurement requires around 500 bytes of data, the data transfer alone will take 4000 times the SPI clock period, not including the measurement itself and the preparation of the SPI transfers.</p>
<p>It is therefore recommended to choose a high transfer speed that is still compatible with the electrical requirements of the sensor as given in the data sheet and the environment in which it is built. An SPI clock frequency in the range of 10 to 12 MHz is a good starting point.</p>
<dl class="section note"><dt>Note</dt><dd>It may not be easy or even possible to set any SPI clock speed. Instead, the SPI speed is often directly coupled with the system clock via a divider.</dd>
<dd>
In case of issues with SPI transfers, start with a lower SPI clock speed (e.g. 1 MHz) and increase successively.</dd></dl>
<h4><a class="anchor" id="autotoc_md31"></a>
DMA Channels</h4>
<p>For the DMA (direct memory access) transfer, usually two separate channels need to be set up for the data read and write.</p>
<p>As the kind of operation always has to be specified by the master within the transfer, the SPI transfers have only two modes:</p>
<ul>
<li>Transmit only</li>
<li>Transmit and receive</li>
</ul>
<p>Both kinds of transfer are started via the <a class="el" href="group__argus__s2pi.html#ga0c8f883938de571dbd73033b4957a987" title="Transfers a single SPI frame asynchronously.">S2PI_TransferFrame()</a> function. While the <code>txData</code> pointer always points to valid data, the <code>rxData</code> pointer is set to <code>0</code> if no data shall be transmitted.</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="group__argus__s2pi.html#ga0c8f883938de571dbd73033b4957a987" title="Transfers a single SPI frame asynchronously.">S2PI_TransferFrame()</a> parameters <code>rxData</code> and <code>txData</code> frequently point to the same memory address. While this should usually be no problem, as the memory byte needs to be read before and stored after the transmission, make sure that the DMA implementation of your MCU supports this! Otherwise, the received data should be transferred to a temporary buffer and copied to the destination after reception.</dd></dl>
<h4><a class="anchor" id="autotoc_md32"></a>
DMA Interrupts and Callback Function</h4>
<p>Usually, the SPI transmission requires a callback function to be triggered after the transmission is complete.</p>
<p>Typically, in the DMA setup, the device provides DMA complete interrupts that can call the callback function. Also, if the <code>CS</code> signal is applied as GPIO (soft <code>CS</code>), it can be unasserted here.</p>
<p>However, this DMA complete callback function may already start the next SPI transfer immediately. So all cleanups required after the current SPI transfer needs to be performed before that. This may be complicated as two DMA channels may be involved in the transmit and receive case and perform cleanup on their individual channel only. The callback function must be triggered only after both channels are freed and cleaned up. Also, the CS must be unasserted before the callback function is called.</p>
<p>On the other hand, in the transmit only case, make sure that the DMA interrupt does not call the callback function, or unassert <code>CS</code>, before the last byte is fully transmitted, especially if the SPI speed is slow.</p>
<h4><a class="anchor" id="autotoc_md33"></a>
DMA Interrupt Priority</h4>
<p>To make use of stable and high frame rates, the SPI interrupt should not be blocked by other possibly longer running interrupts, so the interrupt priority should be chosen sufficiently high. On the other hand, if the target application uses other interrupts for very time sensitive purposes, they should have higher priority, as the callback function may include preparing a new SPI transfer and therefore may take multiple microseconds to return.</p>
<p>An important thing to note is that the API will trigger new SPI transfers within the SPI and GPIO callback functions.</p>
<h2><a class="anchor" id="pg_timer"></a>
Timer Layer</h2>
<p>The <a class="el" href="group__argus__timer.html">Timer Interface</a> implements two timers: a lifetime counter (LTC) for time measurement duties and a periodic interrupt timer (PIT) for the triggering of measurements on a time based schedule.</p>
<dl class="section warning"><dt>Warning</dt><dd>The lifetime counter is mandatory in order to heed the eye-safety limits. Note that this timer must be setup carefully in order to guarantee the laser safety to be within <b>Class 1</b>.</dd></dl>
<h3><a class="anchor" id="autotoc_md34"></a>
Lifetime Counter (LTC)</h3>
<p>The lifetime counter should be set up to deliver the current time in microseconds. The timer resolution must be in the magnitude of 10 to 100 microseconds. This means, however, that the <em>systick</em> counter driven by the <em>systick</em> interrupt cannot be used, as it typically provides an accuracy in the range of milliseconds.</p>
<p>Basically a hardware and a software approach can be chosen to implement the lifetime counter functionality. In any case, a first timer with at least 16-bit width is set to count the sub-seconds value and the prescaler is preferably set such that the timer wraps around after exactly 1 second. In case of a 16-bit counter the maximum achievable granularity is approximately 15 (1/65336) microseconds which is suitable for most applications.</p>
<p>In a hardware based scenario, a second timer with 32-bits is chained to increase its value whenever the first counter wraps around and thus counting seconds. In a software based scenario, the first timer triggers an interrupt upon the wrap around. A 32-bit software counter representing the seconds is increased within the interrupt service routine.</p>
<h3><a class="anchor" id="autotoc_md35"></a>
Periodic Interrupt Timer (PIT)</h3>
<p>Note that the periodic interrupt timer is mandatory only if the user requires the measurements to be started autonomously in the background on a time based schedule. Simple implementations may trigger measurements on demand from the foreground thread and thus the PIT is not required. A weak implementation is provided within the library so that it is not required to implement the interface if the PIT is not used.</p>
<p>A different timer than the timer for the lifetime counter should be used. Usually, the maximum period that will be used can be reached by a combination of the timer reload value and the prescaler even on a 16-bit timer. Extending the period with software is also possible. This can be done by using an additional software counter that counts up every time the interrupts occurs and invokes the callback only after a given number has been reached.</p>
<p>The granularity of the PIT is highly dependent on the required measurement frame rate. E.g. to achieve 1000 frames per seconds, the PIT must be able to trigger every millisecond!</p>
<h2><a class="anchor" id="pg_irq"></a>
Interrupt Layer</h2>
<p>As described in the sections about the S2PI and Timer layers, the Argus API uses three different kinds of interrupts associated with callback functions that have to be set up during the module initialization:</p>
<ol type="1">
<li>SPI DMA Complete Interrupt: This interrupt signals the completion of the DMA transfer. The callback usually triggers a new S2PI transfer or provides a ready indication to the waiting thread. It occurs multiple times during a measurement.</li>
<li>GPIO Interrupt for Data Ready: A low indication on the IRQ line indicates that the requested data was collected on the device and is ready for transfer. This occurs usually twice per measurement (sensor and auxiliary data) and sets up the SPI transfer of the gathered data.</li>
<li>Periodic Interrupt Timer: Periodic measurements are triggered from this interrupt. The callback initiates a new measurement, and therefore should happen only once per measurement cycle. If, however, there is no space to hold the measurement results as the previous results were not yet processed, no new measurement is started and the measurement cycle is delayed or skipped.</li>
</ol>
<h3><a class="anchor" id="autotoc_md36"></a>
Interrupt Priority</h3>
<p>All of these interrupts with their callbacks typically take several microseconds to complete. The callback functions within the API are designed to not induce considerable delays and return as fast as possible.</p>
<p>If other interrupts within the microcontroller are used, their priority should be chosen in the following way:</p>
<ul>
<li>The interrupts described above should get high to medium priority in the order described.</li>
<li>Other interrupts that are very important or time critical below milliseconds should get a higher interrupt priority (typically a lower value).</li>
<li>Other interrupts that are not as important or less time critical should get a lower interrupt priority (typically a higher value).</li>
</ul>
<h3><a class="anchor" id="autotoc_md37"></a>
Concurrency and Interrupt Locking</h3>
<p>The callbacks from the interrupts above provide information or trigger new SPI transfers. In order to prevent concurrency issues, the program must be able to lock the occurrence of these interrupts in atomic or critical sections of the code. Therefore, the <a class="el" href="group__argus__irq.html">IRQ Interface</a> shall be implemented.</p>
<p>In general, the IRQs are only locked for very short time (sub-microseconds) in order read the status and update it appropriately without the interruption from a higher priority thread. However a nested implementation of the locking mechanism is required for the library core to work correctly.</p>
<p>Refer to the module documentation to see an example implementation that locks all maskable interrupts. If other critical interrupts are present, an alternative implementation can selectively lock only the interrupts used by the Argus API.</p>
<h2><a class="anchor" id="pg_nvm"></a>
NVM Layer</h2>
<p>The Non-Volatile Memory (NVM) layer is an optional interface that provides access to a non-volatile memory hardware, e.g. flash. This is used to permanently save calibration parameters that can be gained by executing the corresponding calibration sequences from the [Calibration module](<a class="el" href="group__argus__cal.html">Calibration</a>). Also user set calibration parameters can be saved into the NVM in order to be available after a system reset or power cycle. If custom calibration parameters does not need to be save within the API, the implementation of the interface can be skipped. A weak implementation is provided in the core library that will disable the NVM feature.</p>
<dl class="section note"><dt>Note</dt><dd>Custom calibration data can for example be crosstalk vectors to compensate the impact of cover glass.</dd>
<dd>
The storage of user defined calibration (and configuration) data can also be achieved by using the corresponding API functions and apply the previous parameters after the system reset manually.</dd></dl>
<h2><a class="anchor" id="pg_log"></a>
Log Layer</h2>
<p>In order to send debug and error messages, a <code>printf</code>-like function from the <a class="el" href="group__argus__log.html">Debug Interface</a> can be implemented. If not required, the implementation can be left out and and dummy default implementation will be used that does not send the error messages anywhere. However, implementing this interface may have an impact on the measurement performance, especially when it is slow (e. g. synchronous transfer over UART).</p>
<p>Note that errors are propagated using the <a class="el" href="group__argus__status.html#gaaabdaf7ee58ca7269bd4bf24efcde092" title="Type used for all status and error return values.">status_t</a> enumeration of status and error codes. Any method within the API returns an error code that gives a hint on the execution status of the routine.</p>
<h1><a class="anchor" id="hal_self_test"></a>
Verifying the ported code using the HAL Self Test</h1>
<p>The <b>HAL Self Test</b> module is provide to help the user to verify its ported code on the new platform. It runs a series of simple tests on the target platform and verifies things like SPI, GPIO and timer implementations. In case of timer tests, the connected AFBR-S50 sensor device is used as a reference clock in order to verify the correct timings. Please refer to the <a class="el" href="group__argus__test.html">HAL Self Test</a> module for a detailed documentations.</p>
<p>Here is the modified <a class="el" href="example_app.html#advanced_example_app">Advanced Example</a> from the <a class="el" href="getting_started.html">Getting Started</a> section. The changes are basically an additional include directive and the call to the <a class="el" href="group__argus__test.html#gaeaefab65deb7fdee9faeb9f713e88c6d" title="Executes a series of tests in order to verify the HAL implementation.">Argus_VerifyHALImplementation</a> function. The function call is placed after hardware initialization (i.e. <code>hardware_init</code>) and before device initialization (i.e. <a class="el" href="group__argus__api.html#ga7d724a6657138f112bff554f7db2a898" title="Initializes the device with default measurement mode.">Argus_Init</a>).</p>
<p>Please find the example files in <code>[INSTALL_DIR]\Device\Examples\</code> (default is <code>C:\Program Files (x86)\Broadcom\AFBR-S50 SDK\Device\Examples\</code>).</p>
<p>The HAL self test header and source files are located under <code>[INSTALL_DIR]\Device\Examples\test\</code> (default is <code>C:\Program Files (x86)\Broadcom\AFBR-S50 SDK\Device\Examples\test\</code>).</p>
<p><a class="el" href="01_simple_example_with_hal_self_test_8c-example.html">01_simple_example_with_hal_self_test.c</a> <a class="el" href="02_advanced_example_with_hal_self_test_8c-example.html">02_advanced_example_with_hal_self_test.c</a></p>
<h1><a class="anchor" id="pg_guide"></a>
Step-by-Step Porting Guide</h1>
<p>The following step-by-step guide leads through the basic process on getting the API running on any Cortex-M0 based development environment. The steps are demonstrated using the <a href="https://www.nxp.com/design/software/development-software/mcuxpresso-software-and-tools/mcuxpresso-integrated-development-environment-ide:MCUXpresso-IDE">MCUXpresso-IDE</a> and the <a href="https://www.nxp.com/design/development-boards/freedom-development-boards/mcu-boards/freedom-development-platform-for-kinetis-kl3x-and-kl4x-mcus:FRDM-KL46Z">NXP FRDM-KL46Z</a> development platform from NXP that comes also with the AFBR-S50 evaluation kit. It should be an easy task for experienced embedded software developer to follow the steps on its dedicated development environment.</p>
<dl class="section note"><dt>Note</dt><dd>This is a brief guide that shows the basic approach for porting the API only. An extensive porting guide to a Cortex-M4 architecture is available on the <a href="https://www.broadcom.com/products/optical-sensors/time-of-flight-3d-sensors">Broadcom website</a> (select any Sensor and go to "Documentation" -&gt; "Programming Guides"). This document shows the full task of porting the <b>AFBR-S50 API</b> to a new processor platform on the example of a STM32F403RE Cortex-M4 microprocessor.</dd></dl>
<h2><a class="anchor" id="pg_new_project"></a>
Create a new project in your environment</h2>
<p>The first step would be to create a new empty project or use an existing one. Usually this is done utilizing the provided platform specific SDK provided by the vendor. In case of the FRDM-KL46Z, the MCUXpresso-IDE and the MCUXpresso-SDK is used to create a project with at least SPI (with DMA mode), GPIO and PIT (periodic interrupt timer) support. The new project is tested using the "Hello
World" print statement.</p>
<div class="image">
<img src="4_2_new_project.jpg" alt="" width="800px"/>
<div class="caption">
Fig. 4.2: Creating a new SDK project.</div></div>
 <h2><a class="anchor" id="pg_hw_interface"></a>
Implement hardware interfaces</h2>
<p>After the successfully creating, building and testing the new SDK project, the hardware interfaces required by the AFBR-S50 Core Library need to implemented. Basically there are two approaches: either forward the commands to the provided SDK functionality from the MCU vendor or implement an individual version from scratch.</p>
<p>In order to start, the include files must be referenced in the project and a source file is required for each interface file. The simplest way to include the API into your project is to copy the files. Go to the install directory if the AFBR-S50 SDK and find the files in <code>[INSTALL_DIR]\Device\Lib</code> (see <a class="el" href="#fig_02_lib_dir">Fig. 4.3</a>).</p>
<p><a class="anchor" id="fig_02_lib_dir"></a></p><div class="image">
<img src="4_3_lib_dir.jpg" alt="" width="600px"/>
<div class="caption">
Fig. 4.3: The AFBR-S50 library directory.</div></div>
 <p>The <b>AFBR-S50</b> library and include files are in the AFBR-S50 folder which needs to be copied into the project.</p>
<div class="image">
<img src="4_4_copied_lib_files.jpg" alt="" width="400px"/>
<div class="caption">
Fig. 4.4: The AFBR-S50 library files are copied into the project folder.</div></div>
 <p>Note: The example.c file as well as the platform folder belonging to the examples. See the <a class="el" href="getting_started.html">Getting Started Guide</a> for more information. The platform contains reference implementation of the platform layer which can also be referred for customers implementations.</p>
<p>The include path to the AFBR-S50 header (<code>AFBR-S50\Include</code>) files must be added to the project setting. Afterwards and source file for each individual header file in the <code>AFBR-S50\Include\platform</code> folder must be created and filled with definitions for each function declaration in the header files. Therefore the following files are created:</p>
<ul>
<li><code>argus_s2pi.c</code></li>
<li><code>argus_log.c</code></li>
<li><code>argus_timer.c</code></li>
<li><code>argus_irq.c</code> .</li>
</ul>
<div class="image">
<img src="4_5_setup_project.jpg" alt="" width="800px"/>
<div class="caption">
Fig. 4.5: Setup the include path and add the 'AFBR-S50\Include' folder. Afterwards create a source '*.c' file for each header '*.h' file in the 'AFBR-S50\Include\platform' folder. Create an empty function body for each function declaration in the corresponding header files.</div></div>
 <p>Note that the <code><a class="el" href="argus__nvm_8h.html" title="This file is part of the AFBR-S50 API.">argus_nvm.h</a></code> is ignored in this examples since the usage of the NVM is not required for this demonstration. Default implementations in the AFBR-S50 library core will be used that do not use any non-volatile memory module.</p>
<p>For example, the <code>argus_timer.c</code> file could look like this with empty function bodies:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="argus__timer_8h.html">platform/argus_timer.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="group__argus__timer.html#ga1d634822b505ed359998b94acc5ec8ab">Timer_GetCounterValue</a>(uint32_t * hct, uint32_t * lct)</div>
<div class="line">{ }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="group__argus__timer.html#ga9feb1e1bebe79528bd1b961fab936f24">Timer_SetCallback</a>(<a class="code hl_typedef" href="group__argus__timer.html#gab61822fc55d1007b31bea7298a0b7574">timer_cb_t</a> f)</div>
<div class="line">{ }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="group__argus__timer.html#ga36c65741d5af60b261e68308c0fa9c5f">Timer_SetInterval</a>(uint32_t dt_microseconds, <span class="keywordtype">void</span> * param)</div>
<div class="line">{ }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Timer_Start(uint32_t dt_microseconds, <span class="keywordtype">void</span> * param)</div>
<div class="line">{ }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Timer_Stop(<span class="keywordtype">void</span> * param)</div>
<div class="line">{ }</div>
<div class="ttc" id="aargus__timer_8h_html"><div class="ttname"><a href="argus__timer_8h.html">argus_timer.h</a></div><div class="ttdoc">This file is part of the AFBR-S50 API.</div></div>
<div class="ttc" id="agroup__argus__timer_html_ga1d634822b505ed359998b94acc5ec8ab"><div class="ttname"><a href="group__argus__timer.html#ga1d634822b505ed359998b94acc5ec8ab">Timer_GetCounterValue</a></div><div class="ttdeci">void Timer_GetCounterValue(uint32_t *hct, uint32_t *lct)</div><div class="ttdoc">Obtains the lifetime counter value from the timers.</div></div>
<div class="ttc" id="agroup__argus__timer_html_ga36c65741d5af60b261e68308c0fa9c5f"><div class="ttname"><a href="group__argus__timer.html#ga36c65741d5af60b261e68308c0fa9c5f">Timer_SetInterval</a></div><div class="ttdeci">status_t Timer_SetInterval(uint32_t dt_microseconds, void *param)</div><div class="ttdoc">Sets the timer interval for a specified callback parameter.</div></div>
<div class="ttc" id="agroup__argus__timer_html_ga9feb1e1bebe79528bd1b961fab936f24"><div class="ttname"><a href="group__argus__timer.html#ga9feb1e1bebe79528bd1b961fab936f24">Timer_SetCallback</a></div><div class="ttdeci">status_t Timer_SetCallback(timer_cb_t f)</div><div class="ttdoc">Installs an periodic timer callback function.</div></div>
<div class="ttc" id="agroup__argus__timer_html_gab61822fc55d1007b31bea7298a0b7574"><div class="ttname"><a href="group__argus__timer.html#gab61822fc55d1007b31bea7298a0b7574">timer_cb_t</a></div><div class="ttdeci">void(* timer_cb_t)(void *param)</div><div class="ttdoc">The callback function type for periodic interrupt timer.</div><div class="ttdef"><b>Definition</b> argus_timer.h:166</div></div>
</div><!-- fragment --><p>After testing the build, implement the actual function bodies. Don't forget to implement and call initialization code as well if required.</p>
<p>Here is a simple example of a timer function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="group__argus__timer.html#ga1d634822b505ed359998b94acc5ec8ab">Timer_GetCounterValue</a>(uint32_t * hct, uint32_t * lct)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="group__argus__irq.html#ga7eb2f9c9e40114afd7d079ace7c152e7">IRQ_LOCK</a>();</div>
<div class="line">    LTMR64H = ~(PIT-&gt;LTMR64H);</div>
<div class="line">    LTMR64L = (PIT_Freq - 1U) - PIT-&gt;LTMR64L;</div>
<div class="line">    <a class="code hl_function" href="group__argus__irq.html#ga41f0d51315c5971183de8750606eab22">IRQ_UNLOCK</a>();</div>
<div class="line"> </div>
<div class="line">    *hct = LTMR64H;</div>
<div class="line">    *lct = LTMR64L / PIT_ClocksPerUSec;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__argus__irq_html_ga41f0d51315c5971183de8750606eab22"><div class="ttname"><a href="group__argus__irq.html#ga41f0d51315c5971183de8750606eab22">IRQ_UNLOCK</a></div><div class="ttdeci">void IRQ_UNLOCK(void)</div><div class="ttdoc">Enable IRQ Interrupts.</div></div>
<div class="ttc" id="agroup__argus__irq_html_ga7eb2f9c9e40114afd7d079ace7c152e7"><div class="ttname"><a href="group__argus__irq.html#ga7eb2f9c9e40114afd7d079ace7c152e7">IRQ_LOCK</a></div><div class="ttdeci">void IRQ_LOCK(void)</div><div class="ttdoc">Disable IRQ Interrupts.</div></div>
</div><!-- fragment --><p>Please refer to the platform interface module documentation on details on how to correctly implement the individual layer. Also refer the example implementations of the platform layers that come with the AFBR-S50 SDK, found in <code>[INSTALL_DIR]\Device\Lib\platform\driver</code>. These are:</p>
<ul>
<li><code>irq.c</code>: implements a basic version of the interrupt locking mechanism that allows nested locking which is declared in <a class="el" href="group__argus__irq.html">argus_irq.h</a>.</li>
<li><code>s2pi.c</code>: implements the combined SPI and GPIO interface declared in <a class="el" href="group__argus__s2pi.html">argus_s2pi.h</a>.</li>
<li><code>timer.c</code>: implements the timer functionality declared in <a class="el" href="group__argus__timer.html">argus_timer.h</a>.</li>
<li><code>uart.c</code>: contains the function definition for the [argus_log.h](<a class="el" href="group__argus__log.html">Debug: Logging Interface</a>) header and implements a print functionality over an UART interface. .</li>
</ul>
<h2><a class="anchor" id="pg_linker"></a>
Link Library File</h2>
<p>Now that the platform layers are implemented, the library needs to be linked into the project. Therefore add the <b>AFBR-S50</b> folder (<code>[INSTALL_DIR]\\Device\\Lib\\AFBR-S50</code>) to the library search path and the <code>libafbrs50.a</code> file to the linker libraries (i.e. <code>afbrs50</code>, leaving away the <code>lib</code> and <code>.a</code> in case of GNU toolchain).</p>
<div class="image">
<img src="4_6_setup_linker.jpg" alt="" width="800px"/>
<div class="caption">
Fig. 4.6: Setup the linker by adding the **AFBR-S50** library search path and the `afbrs50` library.</div></div>
 <h2><a class="anchor" id="pg_api"></a>
Utilize the API</h2>
<p>Now, the <b>AFBR-S50 API</b> is ready to use. Include the <code><a class="el" href="argus_8h.html" title="This file is part of the AFBR-S50 API.">argus.h</a></code> header and start coding your AFBR-S50 application. Refer to the <a class="el" href="getting_started.html">Getting Started Guide</a> to see an example implementation with basic measurements. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath">
	<!-- id is needed for treeview function! -->
	<ul>
		<li class="footer"> 
			<a href="https://www.broadcom.com/">Broadcom Inc.</a>
		</li>
	</ul>
</div>
</body>
</html>
