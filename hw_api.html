<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AFBR-S50 API Reference Manual: Explorer App (API Demo)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="AFBR-S50.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AFBR-S50 API Reference Manual
   &#160;<span id="projectnumber">v1.3.5</span>
   </div>
   <div id="projectbrief">AFBR-S50 Time-of-Flight Sensor SDK for Embedded Software</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('hw_api.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Explorer App (API Demo) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_Doxygen_05_explorer_app"></a> The <b>Evaluation Kit</b> runs with a simple demo application, the <b>ExplorerApp</b>. It establishes an USB connection to the <b>AFBR-S50 Explorer GUI</b> that is running on a Windows PC. The ExplorerApp provides a simple interface that allows the GUI to transfer configuration and calibration parameters and receive measurement data.</p>
<p>The ExplorerApp hosts the <b>AFBR-S50 Core Library</b> on the one hand and implements a <b>Serial Communication Interface (SCI)</b> on the other hand. The SCI is an communication protocol that can be used with almost every serial communication interface like UART or USB. The ExplorerApp is the communication slave, while an external host, e.g. the AFBR-S50 Explorer GUI running on Windows, is implemented as a master.</p>
<p>The Evaluation Kit (containing the <a href="https://www.nxp.com/products/processors-and-microcontrollers/arm-microcontrollers/general-purpose-mcus/kl-series-cortex-m0-plus/kinetis-kl4x-48-mhz-usb-segment-lcd-ultra-low-power-microcontrollers-mcus-based-on-arm-cortex-m0-plus-core:KL4x">NXP Kinetis MKL46z</a> MCU) uses the USB interface to connect to the external host (e.g. the AFBR-S50 Explorer). Another reference solution is provided, based on the <a href="https://www.nxp.com/products/processors-and-microcontrollers/arm-microcontrollers/general-purpose-mcus/kl-series-cortex-m0-plus/kinetis-kl1x-48-mhz-mainstream-small-ultra-low-power-microcontrollers-mcus-based-on-arm-cortex-m0-plus-core:KL1x">NXP Kinetis MKL17z</a> MCU, that uses an UART interface to establish a connection to an external host.</p>
<p>The SCI of the ExplorerApp contains a API that is equivalent to the AFBR-S50 API, but accessible via the serial peripheral hardware. The following chapter gives an overview about the architecture and implementation of the SCI module in the ExplorerApp. After gaining a basic understanding of the implementation, it should be an easy task to adopt the <em>ExplorerApp</em> along with the interface to the user requirements and create the host interface that can connect to the provided SCI.</p>
<div class="image">
<img src="5_1_explorerapp.png" alt=""/>
<div class="caption">
Fig. 5.1: An overview of the ExplorerApp Architecture. The ExplorerApp is hosting the AFBR-S50 API on the one hand and a serial communication interface on the other hand to connect to an external host via serial peripheral like USB or UART. The external host would be a PC with running the AFBR-S50 Explorer GUI in case of the evaluation kit.</div></div>
 <h1><a class="anchor" id="hw_mcuxpresso"></a>
Build And Run the ExplorerApp using MCUXpresso IDE</h1>
<p>In order to run the provided ExplorerApp project using the <em>MCUXpresso IDE</em> by NXP, follow the steps 1-6 in the <a class="el" href="getting_started.html#gs_mcuxpresso">Build And Run the Examples using MCUXpresso IDE</a> section to import, build and run/debug the <em>AFBR_S50_ExplorerApp_KL46z</em> project. Skip step 7 and connect to via USB/UART with your SCI master (e.g. using the <em>AFBR-S50 Explorer</em> or the <a class="el" href="hw_api.html#hw_example">Python example</a>) instead.</p>
<h1><a class="anchor" id="hw_api_sci"></a>
Serial Communication Interface</h1>
<h2><a class="anchor" id="hw_api_sci_intro"></a>
Introduction</h2>
<p>The basic idea is to define simple commands (= 7-bit values) to access the AFBR-S50 API. These commands are either transactions with or without data phase. Usually, the commands with data phase are simple getter and setter commands, e.g. "get distance" or "set frame rate".</p>
<p>Each data package starts by the identifier byte (= command byte), followed by a predefined number of data bytes which may be zero. Finally, the package finishes with a CRC byte to verify the data integrity. These byte sequences are called data frames.</p>
<p>The data frames are transmitted in different manner dependent on the underlying hardware interface. However, at a higher level, the command or message layer does not depend on the hardware interface. The communication happens between various systems, whereby one of them needs to be the master. All other participants are slaves which are controlled by the master. Depending on the underlying hardware, there can be a single (e.g. UART) or multiple (e.g. SPI or I2C) slaves. In case of the latter, the slaves are addressed by the master via the corresponding hardware architecture.</p>
<p>Each command to a slave is acknowledged after successful execution. If any error occurs, a not-acknowledge is invoked by the slave. Only a single command can be sent to the slave at once, i.e. the slave has to (not-)acknowledge the command before the master can send another one. A timeout can be implemented in the master to check if the slave responds within a given time and is still alive or if it is stuck in some invalid state.</p>
<h2><a class="anchor" id="hw_api_sci_architecture"></a>
Architecture</h2>
<p>The architecture of the SCI (see <a class="el" href="hw_api.html#sci_layer_model">Fig. 5.2</a>) consists of several layer. Each is communicating on a specific level with its corresponding counterpart.</p>
<p>The lowermost layer is the hardware layer which is the hardware abstraction layer for the underlying hardware, e.g. UART or I2C. The hardware layer transfers data bits over a physical link.</p>
<p>The second layer is the data link layer. It takes care about a reliable transmission of data frames, i.e. a bunch of associated bytes. Therefore it is responsible for putting together data by framing it with a start and a stop byte. It also applies the byte stuffing and finally adds an CRC value to allow the detection of invalid frames.</p>
<p>The third layer is the protocol or message layer. Its responsibility is to transfer messages or commands via the data link layer. In order to achieve a reliable connection, the handshaking is also implemented into this layer via acknowledgment messages.</p>
<p>The last and uppermost layer is the Application or API layer. It provides high level functionality to transfer application specific data.</p>
<p><a class="anchor" id="sci_layer_model"></a></p><div class="image">
<img src="5_2_sci_layer_model.png" alt=""/>
<div class="caption">
Fig. 5.2: The SCI Layer Model.</div></div>
 <p>To sum up:</p><ol type="1">
<li>Hardware Layer: transfer bits over physical medium</li>
<li>Data Link Layer: data framing, byte stuffing and CRC</li>
<li>Message Layer: command, messages and handshaking</li>
<li>Application Layer: host application specific data</li>
</ol>
<dl class="section see"><dt>See also</dt><dd>See also the OSI model, which was used as an reference: <a href="https://en.wikipedia.org/wiki/OSI_model">https://en.wikipedia.org/wiki/OSI_model</a></dd></dl>
<h2><a class="anchor" id="hw_api_hw_layer"></a>
Hardware Layer</h2>
<h3><a class="anchor" id="hw_api_uart"></a>
UART</h3>
<p>The UART interface support only point-to-point communications. It has an independent line for sending as well as receiving data and the slave can transmit data at any time without special actions from the master are required. Therefore, this mode does not require an interrupt line to inform the master about new data ready or error conditions. The data is just transmitted immediately which means that the master must always listen to its Rx line.</p>
<p>The data framing is realized with byte stuffing. There are three special bytes, the start, stop and escape bytes, that are used to determine the boundaries of a data frame. In order to make the start and stop bytes unique and keep the full data range per byte, the corresponding data bytes are inverted and escaped with the escape byte.</p>
<p>In order to provide a handshaking mechanism, the slave acknowledges the successful reception of an data frame (and the successful invocation of the corresponding command) with a short ACK (= acknowledged) or NAK (= not_acknowledged) message within a define time.</p>
<p>Furthermore, due to the independent TX line, the special feature of log and error messages are supported by the UART protocol.</p>
<h3><a class="anchor" id="hw_api_spi"></a>
SPI</h3>
<p>The SPI interface support multiple slave mode via the chip select (CS) lines. Data transfers can only be initiated by the master and thus an extra IRQ line is used to give the slave a chance to call the masters attention to it. This is however optional and the alternative method would be polling the status by the master.</p>
<p>The data framing is realized via the CS. After the command byte, the data is transferred either by on the MISO or MOSI for a read or write command respectively.</p>
<p>The handshaking is implemented via the IRQ line. If an error occurs, the IRQ is pulled to low. The master can now read the corresponding status in order to get the root cause of the IRQ. Also the new measurement ready event is determined via the IRQ. In addition, the acknowledgment of the successful reception and execution of a command could be implemented via the interrupt; the master would responsible for reading the acknowledge status.</p>
<h3><a class="anchor" id="hw_api_i2c"></a>
I2C</h3>
<p>The I2C interface supports multiple slave mode via the device address bytes. Data transfers can only be initiated by the master and thus an extra IRQ line is used to give the slave a chance to call the masters attention to it. This is however optional and the alternative method would be polling the status by the master.</p>
<p>The data framing is realized via the usual I2C protocol. Every frame is started with the I2C start condition followed by the devices write address and then master writes the command. In case of a write command, the data can follow immediately. In case of an read command, the devices read address is placed after an repeated start condition. The slave will put its data to the SDA line afterwards.</p>
<p>Besides the already build-in acknowledgment mechanism form the I2C protocol, the reception of an invalid data frame is advertised via the IRQ line. If an error occurs, the IRQ is pulled to low. The master can now read the corresponding status in order to get the root cause of the IRQ. Also the new measurement ready event is determined via the IRQ. In addition, the In addition, the acknowledgment of the successful reception and execution of a command could be implemented via the interrupt; the master would responsible for reading the acknowledge status.</p>
<h2><a class="anchor" id="hw_api_cmd_protocols"></a>
Command Protocols</h2>
<h3><a class="anchor" id="hw_api_cmd_m2s"></a>
Master-to-Slave Transfer</h3>
<div class="image">
<img src="5_3_sci_master_to_slave.png" alt=""/>
<div class="caption">
Fig. 5.3: The master to slave communication. The left side shows the UART hardware and the right side the version for SPI/I2C hardware.</div></div>
 <p>In case of UART, the master simply send data via its Tx line. After processing, the slave responds with an acknowledge or not-acknowledge signal on the masters Rx line.</p>
<p>In case of SPI or I2C, the slave can not send data without the master initiating the transfer. Thus, an additional IRQ is used to give the slave the chance to call the masters attention. In case of no IRQ available, the master must poll the slave on a regular basis. So after processing, the slave signals when he is ready to send the acknowledge or not-acknowledge signal and afterwards the master must initiate the transfer from slave to master.</p>
<h3><a class="anchor" id="hw_api_cmd_s2m"></a>
Slave-to-Master Transfer</h3>
<div class="image">
<img src="5_4_sci_slave_to_master.png" alt=""/>
<div class="caption">
Fig. 5.4: The slave to master communication. The left side shows the UART hardware and the right side the version for SPI/I2C hardware.</div></div>
 <p>In case of UART, the slave simply sends data via its Tx line. After receiving on the master, the sent data is dismissed. If an error occurs, the master is responsible to react accordingly, e.g. re-initiating the transfer by re-sending the previous command.</p>
<p>In case of SPI or I2C, the slave can not send data without the master initiating the transfer. Thus, an additional IRQ is used to give the slave the chance to call the masters attention. In case of no IRQ available, the master must poll the slave on a regular basis. The slave signals when he wants to send data via the IRQ and afterwards the master must initiate the transfer from slave to master.</p>
<h2><a class="anchor" id="hw_api_cmd_format"></a>
Command Byte Format</h2>
<p>Every command message is identified by the first byte in a data frame. This byte is an unique number that is mapped to a specified parameter/value/command.</p>
<p>The command identifier consists of 7-bit.</p>
<p>In consideration of future applications (advanced commands, addressed commands, â€¦), the MSB is reserved (escape bit) and always 0. The remaining 7-bits determine the command.</p>
<div class="image">
<img src="5_5_sci_command_byte.png" alt=""/>
<div class="caption">
Fig. 5.5: The command byte format.</div></div>
 <p>Reserved Command Bytes</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Byte   </th><th class="markdownTableHeadNone">Comment    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">&gt; 127   </td><td class="markdownTableBodyNone">MSB is reserved for later use    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x02   </td><td class="markdownTableBodyNone">ASCII: Start of text    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x03   </td><td class="markdownTableBodyNone">ASCII: End of text    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x1B   </td><td class="markdownTableBodyNone">ASCII: Escape    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x21   </td><td class="markdownTableBodyNone">ASCII: ! - reserved for later use    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x23   </td><td class="markdownTableBodyNone">ASCII: # - reserved for later use    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x24   </td><td class="markdownTableBodyNone">ASCII: $ - reserved for later use    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x3F   </td><td class="markdownTableBodyNone">ASCII: ? - reserved for later use   </td></tr>
</table>
<h2><a class="anchor" id="hw_api_cmd_types"></a>
Command Types</h2>
<p>There are several command types defined:</p>
<ul>
<li><b>Command (cmd)</b>: A data frame with a command byte that determines a simple command message that will invoke an action on the slave side. The commands are send from the master to the slave. The slave executes a corresponding function. Usually there is no data phase but in some cases there might be some (optional) function parameter.</li>
<li><b>Setter (set)</b>: Command byte followed by a given sequence of data bytes representing the data that needs to be transferred from the master to the slave.</li>
<li><b>Getter (get)</b>: A request from the master to read data from the slave. The actual data read phase depends a bit on the underlying hardware. While for SPI and I2C, the data is read directly in the context of the message, the response is sent as an autonomous message from the slave via its UART Tx line. Note that a get message is actually a command message that invokes the data transfer from the slave to the master in case of UART. Note that for some get messages there might be a short data phase for additional specification of the data to be read, e.g. an index number.</li>
<li><b>Automatic / Autonomous Push (Auto / Push)</b>: A message or data transfer that is initiated by the slave. Depending on the hardware, the slave requests a data transfer by the data-ready pin or simply invokes the transfer in an autonomous way. The first is the case for I2C and SPI modes while the latter is the case for UART mode. This type of message is utilized by the slave to send log messages or establish an data stream of new measurement data to the master without the requirement of polling the line.</li>
</ul>
<p>Thus a single command byte can have up to three different intentions.</p>
<ul>
<li><b>cmd</b>: Executing actions.</li>
<li><b>get</b>: The usual getter for read-only data.</li>
<li><b>set / get</b> The setter/getter combination e.g. for configuration parameters that can be applied to the slave and also read back.</li>
<li><b>auto / push</b>: Data that is only send from the slave as needed without the request form the master, e.g. log messages or data streaming.</li>
</ul>
<h2><a class="anchor" id="hw_api_frame_format"></a>
Data Frame Format</h2>
<div class="image">
<img src="5_6_sci_data_frames.png" alt=""/>
<div class="caption">
Fig. 5.6: The data frame format for different hardware.</div></div>
 <p>Each message or command that is sent over underlying hardware is put into a data frame. A data frame is a sequence of bytes with variable length that contains arbitrary data. Depending on the hardware, the boundaries of the data frames are given in an unique way.</p>
<p>The first byte within a data frame is the command byte that uniquely determines the purpose and thus the format of the data frame. The last byte within the data frame is the security byte that contains a CRC value that guarantees the data integrity of the receive frame. Between the command and CRC bytes, there is an optional data phase of arbitrary length. The format and interpretation of the data is determined by the command byte in the higher layers of the communication stack and does not have any influence for the data framing.</p>
<h3><a class="anchor" id="hw_api_byte_stuffing"></a>
Byte Stuffing Algorithm</h3>
<p>In case of SPI and I2C, the data framing is incorporated into the hardware protocol itself, while for the UART interface, a software solution is implemented. The SPI data frame is given by the chip select signal. Each data byte that comes while the chip select line stays at low are combined to a single frame until the chip select is released. The I2C protocol implements an embedded start and stop signal that gives the boundaries of a single data frame.</p>
<p>The UART version implements the data framing in software via byte stuffing, since there is no mechanism to detect the start of a new data package build into the hardware interface. The ideas is to reserve some unique byte values to serve as special control signal, e.g. start and stop bytes. Now, all bytes within a start and a stop byte are interpreted as data bytes for a single data frame. In order to not loose the full range of 256 valid values per data byte, an additional escape signal is introduced. Whenever a byte value equal to the value of start, stop or escape byte appears as a data byte within the current frame, an escape byte is added prior to the byte in question in order to signal that the following value is not an control signal but an ordinary data value. In order to increase security further, escaped data bytes are inverted to make the three control values unique.</p>
<p>Here are the control byte definitions:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Byte   </th><th class="markdownTableHeadNone">Comment    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Start Flag   </td><td class="markdownTableBodyNone">0x02   </td><td class="markdownTableBodyNone">ASCII: Start of text    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Stop Flag   </td><td class="markdownTableBodyNone">0x03   </td><td class="markdownTableBodyNone">ASCII: End of text    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Escape Flag   </td><td class="markdownTableBodyNone">0x1B   </td><td class="markdownTableBodyNone">ASCII: Escape   </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd><a href="https://eli.thegreenplace.net/2009/08/12/framing-in-serial-communications">https://eli.thegreenplace.net/2009/08/12/framing-in-serial-communications</a></dd></dl>
<h4><a class="anchor" id="autotoc_md16"></a>
Byte Stuffing Algorithm for Sending Data</h4>
<p>The algorithm to send a data frame with byte stuffing:</p>
<ol type="1">
<li>Create a new data buffer with start byte included at the first position.</li>
<li>Append the data in the buffer (command and data) and add escape bytes on the fly, invert escaped bytes.</li>
<li>Calculate the CRC on that buffer, but ignore all escaped bytes, i.e resolve byte stuffing</li>
<li>Add the CRC value (and maybe escape signal) and the Stop byte.</li>
<li>Send the buffer.</li>
</ol>
<h4><a class="anchor" id="autotoc_md17"></a>
Byte Stuffing Algorithm for Receiving Data</h4>
<p>The algorithm to receive data with byte stuffing:</p>
<ol type="1">
<li>After detecting a start byte, start receiving all data until the subsequent stop byte.</li>
<li>Write the received bytes into a buffer, removing escape bytes and invert escaped bytes on the fly</li>
<li>Calculate and verify the CRC value.</li>
<li>Evaluate the data buffer by invoking the corresponding function belonging to the given command byte.</li>
</ol>
<h3><a class="anchor" id="hw_api_crc"></a>
Error checking: 8-bit CRC</h3>
<p>In order to guarantee the data integrity of the received data frame, a CRC value is added to each data frame.</p>
<p>CRC8_SAE_J1850_ZERO definitions:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Byte    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CRC Generator Byte   </td><td class="markdownTableBodyNone">0x1D    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CRC Start Value   </td><td class="markdownTableBodyNone">0x00   </td></tr>
</table>
<p>Refer to the following link to verify your implementation of the <em>CRC8_SAE_J1850_ZERO</em> algorithm:</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.sunshine2k.de/coding/javascript/crc/crc_js.html">http://www.sunshine2k.de/coding/javascript/crc/crc_js.html</a></dd></dl>
<h1><a class="anchor" id="autotoc_md18"></a>
Command Definitions</h1>
<h2><a class="anchor" id="autotoc_md19"></a>
Overview</h2>
<p>Go to: <a class="el" href="hw_api_cmd_overview.html">Command Overview</a></p>
<h2><a class="anchor" id="autotoc_md20"></a>
Details</h2>
<p>Go to: <a class="el" href="hw_api_cmd_details.html">Command Details</a></p>
<h1><a class="anchor" id="hw_example"></a>
Python Example on Using the SCI Interface</h1>
<p>Here is an example that sets some configuration parameters (i.e. data output = 1D data only; measurement frame rate = 5 Hz) and starts timer based measurements. The range is extracted from the received data structure and printed to the console.</p>
<p>The example is very basic though. The sent data frames are manually created (i.e. data encoding, byte stuffing and CRC are hard coded). It ignores the received Acknowledge/NotAcknowledge commands and cannot handle unexpected data from the device.</p>
<p>The file runs with Python (3.6) and requires the Python serial module (pySerial).</p>
<p>Please find the file in "[INSTALL_DIR]\Device\Examples\sci_python_example.py" (default is "C:\Program Files (x86)\Broadcom\AFBR-S50 SDK\Device\Examples\sci_python_example.py").</p>
<div class="fragment"><div class="line"><span class="comment"># #############################################################################</span></div>
<div class="line"><span class="comment"># ###     Example for using the AFBR-S50 API with UART interface            ###</span></div>
<div class="line"><span class="comment"># #############################################################################</span></div>
<div class="line"><span class="comment">#</span></div>
<div class="line"><span class="comment"># Prepare your evaluation kit (w/ NXP MKL46z MCU) by flashing the UART binary</span></div>
<div class="line"><span class="comment"># to the device. Connect the OpenSDA USB port (NOT the one labeled with KL46Z)</span></div>
<div class="line"><span class="comment"># to your computer. Go to the Device/Binary folder install directory of you SDK</span></div>
<div class="line"><span class="comment"># (default: C:\Program Files (x86)\Broadcom\AFBR-S50 SDK\Device\Binary) and copy</span></div>
<div class="line"><span class="comment"># the AFBR.S50.ExplorerApp.vX.X.X_KL46z_UART.srec (not the *_USB.*!!) file to</span></div>
<div class="line"><span class="comment"># the OpenSDA USB drive.</span></div>
<div class="line"><span class="comment">#</span></div>
<div class="line"><span class="comment"># After flashing, the device is ready to receive commands via the OpenSDA serial</span></div>
<div class="line"><span class="comment"># port. Go to your device manager to find out which COM port is assigned to the</span></div>
<div class="line"><span class="comment"># device. Type it to the &quot;port&quot; variable below, before starting the script.</span></div>
<div class="line"><span class="comment">#</span></div>
<div class="line"><span class="comment"># Use Python 3 to run the script. The script requires the pySerial module which</span></div>
<div class="line"><span class="comment"># might need to be installed. </span></div>
<div class="line"><span class="comment"># To install, run: &quot;pip install pyserial&quot;</span></div>
<div class="line"><span class="comment"># See: https://pyserial.readthedocs.io/en/latest/index.html</span></div>
<div class="line"><span class="comment">#</span></div>
<div class="line"><span class="comment">#</span></div>
<div class="line"><span class="comment"># The script sends configuration commands to set the data output mode to 1D data</span></div>
<div class="line"><span class="comment"># only and the frame rate to 5 Hz. After setting the configuration, the</span></div>
<div class="line"><span class="comment"># measurements are started and the data is extracted from the received data</span></div>
<div class="line"><span class="comment"># frames and printed to the console.</span></div>
<div class="line"><span class="comment">#</span></div>
<div class="line"><span class="comment">#</span></div>
<div class="line"><span class="comment"># Note: The CRC values are calculated manually and added before the frames are</span></div>
<div class="line"><span class="comment"># sent. You can use the online calculator from the following link w/</span></div>
<div class="line"><span class="comment"># CRC8_SAE_J1850_ZERO to obtain the CRC values for a frame:</span></div>
<div class="line"><span class="comment"># http://www.sunshine2k.de/coding/javascript/crc/crc_js.html</span></div>
<div class="line"><span class="comment">#</span></div>
<div class="line"><span class="comment"># #############################################################################</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> time</div>
<div class="line"><span class="keyword">import</span> serial</div>
<div class="line"> </div>
<div class="line"><span class="comment"># input parameters</span></div>
<div class="line">port = <span class="stringliteral">&quot;COM5&quot;</span></div>
<div class="line">baudrate = 115200</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>AFBR_S50:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    Serial Communication Interface for the AFBR-S50 Device.</span></div>
<div class="line"><span class="stringliteral">    Connects to the device via a UART interface.</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">    </div>
<div class="line">    start_byte = b<span class="stringliteral">&#39;\x02&#39;</span></div>
<div class="line">    </div>
<div class="line">    stop_byte = b<span class="stringliteral">&#39;\x03&#39;</span></div>
<div class="line">    </div>
<div class="line">    esc_byte = b<span class="stringliteral">&#39;\x1B&#39;</span></div>
<div class="line">    </div>
<div class="line">    cmd_ack = 0x0A</div>
<div class="line">    </div>
<div class="line">    cmd_nak = 0x0B</div>
<div class="line">    </div>
<div class="line">    ser = <span class="keywordtype">None</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__init__(self, port, baudrate):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;!</span></div>
<div class="line"><span class="stringliteral">        Initializes the class and opens a serial port w/</span></div>
<div class="line"><span class="stringliteral">        &quot;115200,8,N,1&quot; serial settings and no timeout.</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">        @param port (str): The port number string, e.g. &quot;COM1&quot;</span></div>
<div class="line"><span class="stringliteral">        @param baudrate (int): The baud rate in bauds per second, e.g. 115200</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        <a class="code" href="group__argus__log.html#gaf623b0ecc471d68c31c110c6f9abd7d2">print</a>(<span class="stringliteral">&quot;AFBR-S50: Open Serial Port &quot;</span> + port)</div>
<div class="line">        self.ser = serial.Serial(port, baudrate)</div>
<div class="line">        self.ser.timeout = 1.0 <span class="comment"># seconds</span></div>
<div class="line">        <a class="code" href="group__argus__log.html#gaf623b0ecc471d68c31c110c6f9abd7d2">print</a>(<span class="stringliteral">&quot;AFBR-S50: Serial Port is open &quot;</span> + port + <span class="stringliteral">&quot;: &quot;</span> + str(self.ser.is_open))</div>
<div class="line">    </div>
<div class="line">        <span class="comment"># discard old data</span></div>
<div class="line">        <span class="keywordflow">if</span> self.ser.inWaiting() &gt; 0:</div>
<div class="line">            self.ser.read(self.ser.inWaiting()) </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__del__(self):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;!</span></div>
<div class="line"><span class="stringliteral">        Deletes the class and closes the opened serial port.</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        self.ser.close()</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>write(self, tx: bytes):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;!</span></div>
<div class="line"><span class="stringliteral">        Sends a SCI message and waits for an optional answer and</span></div>
<div class="line"><span class="stringliteral">        the mandatory acknowledge.</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">        If any answer is received, it is returned as bytearray.</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">        @param tx (bytes): The data message (incl. excape bytes) as byte array to be sent.</span></div>
<div class="line"><span class="stringliteral">        @return Returns the received answer (ACK or NAK) as byte array. None if no answer was received.</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        <a class="code" href="group__argus__log.html#gaf623b0ecc471d68c31c110c6f9abd7d2">print</a>(<span class="stringliteral">&quot;Sending: &quot;</span> + tx.hex())</div>
<div class="line">        self.ser.write(tx)</div>
<div class="line">        <span class="keywordflow">return</span> self.__wait_for_ack(tx[1]) <span class="comment"># read acknowledge</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__wait_for_ack(self, txcmd):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;!</span></div>
<div class="line"><span class="stringliteral">        Waits for an acknowledge signal for the specified command.</span></div>
<div class="line"><span class="stringliteral">        If an answer is received before the acknowledge is received,</span></div>
<div class="line"><span class="stringliteral">        the answer is returned as a bytearray.</span></div>
<div class="line"><span class="stringliteral">        If no acknowledge or any other command is received, an</span></div>
<div class="line"><span class="stringliteral">        exception is raised.</span></div>
<div class="line"><span class="stringliteral">        @param txcmd (byte): The TX command byte to await an acknowledge for.</span></div>
<div class="line"><span class="stringliteral">        @return Returns the received answer (ACK or NAK) as byte array. None if no answer was received.</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        answer = <span class="keywordtype">None</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line">            <span class="comment"># Read until next stop byte and remove escape bytes</span></div>
<div class="line">            rx = bytearray(self.ser.read_until(self.stop_byte))</div>
<div class="line">            <span class="keywordflow">if</span> len(rx) == 0:</div>
<div class="line">                <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&quot;No data was read from the RX line.&quot;</span>)</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> rx[0] != self.start_byte[0] <span class="keywordflow">or</span> rx[-1] != self.stop_byte[0]:</div>
<div class="line">                <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&quot;Invalid data frame received (start or stop byte missing).&quot;</span>)</div>
<div class="line">                </div>
<div class="line"> </div>
<div class="line">            rx = self.__remove_byte_stuffing(rx)</div>
<div class="line">    </div>
<div class="line">            <span class="comment"># Extract command byte (first after start byte)</span></div>
<div class="line">            rxcmd = rx[1]</div>
<div class="line">    </div>
<div class="line">            <span class="keywordflow">if</span> rxcmd == txcmd: <span class="comment"># response received</span></div>
<div class="line">                answer = rx</div>
<div class="line">    </div>
<div class="line">            <span class="comment"># acknowledge signal received</span></div>
<div class="line">            <span class="keywordflow">elif</span> rxcmd == self.cmd_ack: </div>
<div class="line">                ackcmd = rx[2]</div>
<div class="line"> </div>
<div class="line">                <span class="comment"># acknowledge for the current command</span></div>
<div class="line">                <span class="keywordflow">if</span> ackcmd == txcmd: </div>
<div class="line">                    <span class="keywordflow">return</span> answer</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># acknowledge for any other command</span></div>
<div class="line">                <span class="keywordflow">else</span>: </div>
<div class="line">                    <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&quot;Invalid ACK received&quot;</span>)</div>
<div class="line">    </div>
<div class="line">            <span class="comment"># not-acknowledge signal received</span></div>
<div class="line">            <span class="keywordflow">elif</span> rxcmd == self.cmd_nak:</div>
<div class="line">                nakcmd = rx[2]</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># not-acknowledge for current command</span></div>
<div class="line">                <span class="keywordflow">if</span> nakcmd == txcmd:</div>
<div class="line">                    <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&quot;NAK received&quot;</span>)</div>
<div class="line"> </div>
<div class="line">                <span class="comment"># not-acknowledge for any other command</span></div>
<div class="line">                <span class="keywordflow">else</span>:</div>
<div class="line">                    <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&quot;Invalid NAK received&quot;</span>)</div>
<div class="line">    </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__remove_byte_stuffing(self, rx: bytearray):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;!</span></div>
<div class="line"><span class="stringliteral">        Removes escape bytes from the incoming message if any</span></div>
<div class="line"><span class="stringliteral">        @param rx (bytearray): The data message as byte array with escape bytes.</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        rxi = rx.split(self.esc_byte)</div>
<div class="line">        rx = b<span class="stringliteral">&#39;&#39;</span></div>
<div class="line">        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1, len(rxi)):</div>
<div class="line">            rxi[i][0] ^= 0xFF <span class="comment"># invert byte after escape byte (also inverts start byte, but we don&#39;t care..)</span></div>
<div class="line">        <span class="keywordflow">return</span> rx.join(rxi)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__extract_1d_data(self, rx: bytearray):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;!</span></div>
<div class="line"><span class="stringliteral">        Extracts the 1D data values from the 1D data message.</span></div>
<div class="line"><span class="stringliteral">        @param rx (bytearray): The 1D data message as byte array without escape bytes.</span></div>
<div class="line"><span class="stringliteral">        @return Returns the read data as dictionary. </span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        d = dict()</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Extract Status:</span></div>
<div class="line">        s = (rx[2] &lt;&lt; 8) + rx[3]</div>
<div class="line">        d[<span class="stringliteral">&#39;status&#39;</span>] = s <span class="keywordflow">if</span> s &lt; 0x8000 <span class="keywordflow">else</span> s - 0x10000 <span class="comment"># convert to signed 16-bit int </span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Extract Time Stamp</span></div>
<div class="line">        t_sec = (rx[4] &lt;&lt; 24) + (rx[5] &lt;&lt; 16) + (rx[6] &lt;&lt; 8) + rx[7]</div>
<div class="line">        t_usec = (rx[8] &lt;&lt; 8) + rx[9]</div>
<div class="line">        d[<span class="stringliteral">&#39;timestamp&#39;</span>] = t_sec + t_usec * 16.0 / 1.0e6</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Extract Range:</span></div>
<div class="line">        r = (rx[12] &lt;&lt; 16) + (rx[13] &lt;&lt; 8) + rx[14]</div>
<div class="line">        d[<span class="stringliteral">&#39;range&#39;</span>] = r / 16384.0 <span class="comment"># convert from Q9.14</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Extract Amplitude:</span></div>
<div class="line">        a = (rx[15] &lt;&lt; 8) + rx[16]</div>
<div class="line">        d[<span class="stringliteral">&#39;amplitude&#39;</span>] = a / 16.0 <span class="comment"># convert from UQ12.4</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Extract Signal Quality:</span></div>
<div class="line">        q = rx[17]</div>
<div class="line">        d[<span class="stringliteral">&#39;signal quality&#39;</span>] = q</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> d</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>read_data(self):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;!</span></div>
<div class="line"><span class="stringliteral">        Reads the serial port and decodes the SCI data messages.</span></div>
<div class="line"><span class="stringliteral">        Currently only 1D data messages are supported.</span></div>
<div class="line"><span class="stringliteral">        If no data is pending to be read, the function immediately</span></div>
<div class="line"><span class="stringliteral">        return with None. If other data than measurement data was read,</span></div>
<div class="line"><span class="stringliteral">        the function returns with None.</span></div>
<div class="line"><span class="stringliteral">        Otherwise it returns a dictionary with the extracted data values.</span></div>
<div class="line"><span class="stringliteral">        @return Returns the read data as dictionary. None if no data has been read.</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">if</span> self.ser.inWaiting() &gt; 0:</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># Read until next stop byte and remove escape bytes</span></div>
<div class="line">            rx = bytearray(self.ser.read_until(self.stop_byte))</div>
<div class="line">            <span class="keywordflow">if</span> len(rx) == 0:</div>
<div class="line">                <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&quot;No data was read from the RX line.&quot;</span>)</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> rx[0] != self.start_byte[0] <span class="keywordflow">or</span> rx[-1] != self.stop_byte[0]:</div>
<div class="line">                <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&quot;Invalid data frame received (start or stop byte missing).&quot;</span>)</div>
<div class="line"> </div>
<div class="line">            rx = self.__remove_byte_stuffing(rx)</div>
<div class="line">        </div>
<div class="line">            <span class="comment"># extract command byte (first after start byte)</span></div>
<div class="line">            cmd = rx[1]</div>
<div class="line">        </div>
<div class="line">            <span class="keywordflow">if</span> cmd == 0x06: <span class="comment"># Log Message</span></div>
<div class="line">                <a class="code" href="group__argus__log.html#gaf623b0ecc471d68c31c110c6f9abd7d2">print</a>(<span class="stringliteral">&quot;Device Log: &quot;</span> + str(rx[8:-2]))</div>
<div class="line">        </div>
<div class="line">            <span class="keywordflow">elif</span> cmd == 0x36: <span class="comment"># 1D Data Set</span></div>
<div class="line">                <span class="keywordflow">return</span> self.__extract_1d_data(rx)</div>
<div class="line">        </div>
<div class="line">            <span class="keywordflow">else</span>: <span class="comment"># Unknown or not handled here</span></div>
<div class="line">                <a class="code" href="group__argus__log.html#gaf623b0ecc471d68c31c110c6f9abd7d2">print</a>(<span class="stringliteral">&quot;Received Unknown Data Frame: &quot;</span> + rx.hex())</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> __name__ == <span class="stringliteral">&quot;__main__&quot;</span>:</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span>:</div>
<div class="line">        <span class="comment"># Create a new instance and open a serial port connection to the device.</span></div>
<div class="line">        s50 = AFBR_S50(port, baudrate)</div>
<div class="line">    </div>
<div class="line">        <span class="comment"># Setting data output mode to 1D data only</span></div>
<div class="line">        <span class="comment"># The message is composed of:</span></div>
<div class="line">        <span class="comment"># [START][CMD][PARAM][CRC][STOP]</span></div>
<div class="line">        <span class="comment"># where:</span></div>
<div class="line">        <span class="comment"># [START] = 0x02; start byte</span></div>
<div class="line">        <span class="comment"># [CMD]   = 0x41; command byte: data streaming mode</span></div>
<div class="line">        <span class="comment"># [PARAM] = 0x07; parameter of command: 1d data streaming</span></div>
<div class="line">        <span class="comment"># [CRC]   = 0xF5; checksum: pre-calculated in online calculator</span></div>
<div class="line">        <span class="comment"># [STOP]  = 0x03; stop byte</span></div>
<div class="line">        <a class="code" href="group__argus__log.html#gaf623b0ecc471d68c31c110c6f9abd7d2">print</a>(<span class="stringliteral">&quot;setting data output mode to 1d data only&quot;</span>)</div>
<div class="line">        s50.write(bytes.fromhex(<span class="stringliteral">&#39;02 41 07 F5 03&#39;</span>))</div>
<div class="line">    </div>
<div class="line">        <span class="comment"># Setting frame time to 200000 Âµsec = 0x00030D40 Âµsec</span></div>
<div class="line">        <span class="comment"># The message is composed of:</span></div>
<div class="line">        <span class="comment"># [START][CMD][PARAM(0)]...[PARAM(N)][CRC][STOP]</span></div>
<div class="line">        <span class="comment"># where:</span></div>
<div class="line">        <span class="comment"># [START]    = 0x02; start byte</span></div>
<div class="line">        <span class="comment"># [CMD]      = 0x43; command byte: measurement frame time</span></div>
<div class="line">        <span class="comment"># [PARAM(x)] = 0x001BFC0D40; 4-bit parameter of command: 0x00 03 0D 40 w/ escape bytes </span></div>
<div class="line">        <span class="comment"># [CRC]      = 0x85; checksum: pre-calculated in online calculator</span></div>
<div class="line">        <span class="comment"># [STOP]     = 0x03; stop byte</span></div>
<div class="line">        <span class="comment">#</span></div>
<div class="line">        <span class="comment"># NOTE: the 0x03 byte must be escaped and inverted (i.e. use 0x1BFC instead of 0x03)</span></div>
<div class="line">        <span class="comment">#       The CRC is calculated on the original data, i.e. 0x43 00 03 0D 40 =&gt; 0x85</span></div>
<div class="line">        <a class="code" href="group__argus__log.html#gaf623b0ecc471d68c31c110c6f9abd7d2">print</a>(<span class="stringliteral">&quot;setting frame rate to 5 Hz (i.e. frame time to 0.2 sec)&quot;</span>)</div>
<div class="line">        s50.write(bytes.fromhex(<span class="stringliteral">&#39;02 43 00 1B FC 0D 40 85 03&#39;</span>))</div>
<div class="line">    </div>
<div class="line">        <span class="comment"># Starting measurements</span></div>
<div class="line">        <span class="comment"># [CMD] = 0x11; command byte: start timer based measurements</span></div>
<div class="line">        <a class="code" href="group__argus__log.html#gaf623b0ecc471d68c31c110c6f9abd7d2">print</a>(<span class="stringliteral">&quot;starting measurements in timer based auto mode&quot;</span>)</div>
<div class="line">        s50.write(bytes.fromhex(<span class="stringliteral">&#39;02 11 D0 03&#39;</span>))</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Read measurement data</span></div>
<div class="line">        <a class="code" href="group__argus__log.html#gaf623b0ecc471d68c31c110c6f9abd7d2">print</a>(<span class="stringliteral">&quot;read measurement data&quot;</span>)</div>
<div class="line">        <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line">            d = s50.read_data()</div>
<div class="line">            <span class="keywordflow">if</span> d != <span class="keywordtype">None</span>:</div>
<div class="line">                <a class="code" href="group__argus__log.html#gaf623b0ecc471d68c31c110c6f9abd7d2">print</a>(d)</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">else</span>:</div>
<div class="line">                <span class="comment"># do other stuff</span></div>
<div class="line">                time.sleep(0.1)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">except</span> KeyboardInterrupt:</div>
<div class="line">        <span class="comment"># Try to stop measurements</span></div>
<div class="line">        <span class="comment"># [CMD] = 0x12; command byte: stop timer based measurements</span></div>
<div class="line">        <a class="code" href="group__argus__log.html#gaf623b0ecc471d68c31c110c6f9abd7d2">print</a>(<span class="stringliteral">&quot;stop measurements&quot;</span>)</div>
<div class="line">        s50.write(bytes.fromhex(<span class="stringliteral">&#39;02 12 F7 03&#39;</span>))</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="ttc" id="agroup__argus__log_html_gaf623b0ecc471d68c31c110c6f9abd7d2"><div class="ttname"><a href="group__argus__log.html#gaf623b0ecc471d68c31c110c6f9abd7d2">print</a></div><div class="ttdeci">status_t print(const char *fmt_s,...)</div><div class="ttdoc">A printf-like function to print formated data to an debugging interface.</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath">
	<!-- id is needed for treeview function! -->
	<ul>
		<li class="footer"> 
			<a href="https://www.broadcom.com/">Broadcom Inc.</a>
		</li>
	</ul>
</div>
</body>
</html>